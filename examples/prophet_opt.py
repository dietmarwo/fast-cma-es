'''
    How to optimize an AI generated algorithmic trading strategy?
    
    Resolve dependencies:
    
    pip install plotly 
    pip install yfinance==0.2.24
    pip install fcmaes --upgrade
    pip install prophet
    
    This example code is partly generated by o1-preview.  
    LLMs can help to generate the code, and to understand 
    its concepts. It can even propose ways to optimize the trading
    strategy. This example shows how this optimization process can be 
    automated using fcmaes. 
    
    - Executing the trading strategy takes time, so a complete parameter
    sweep is slow.
    - We exploit the fact the fcmaes uses parallel processes to speed up
    the optimization process. 
    - An evolutionary optimizer (Differential Evolution) refines "promising"
    parameter sets, thereby avoiding to get stuck at local optima.
    
    Used o1-preview prompts:

    'why are HMMs not typically used for point forecasts?'
    
        o1-preview lists the reasons, shows alternatives, 
        one is to use the time-series library Prophet from Facebook.

    'show python code using Prophet for implementing a trading strategy'    
    'list this code in one chunk'
    
        the generated code desn't work with newest yfinance, so use
        pip install yfinance==0.2.24

    'how can the code be adapted to bitcoin reflecting the 4 year bitcoin cycle?'
    'apply this model to implement and test a trading strategy for BTC'
    
    Now we want to know how to optimize the strategy:

    'what can I try to optimize market return?'
    
        - Experiment with different values of changepoint_prior_scale.
        - Adjust the fourier_order for the yearly and custom 4-year seasonalities.
        - Change Seasonality Modes, can be either 'additive' or 'multiplicative'
        - ...

    Additionally - not mentioned by o1-preview -  we could vary the 4-year cycle.

    o1-preview doesn't tell us how to do that. We show how fcmaes Differential Evolution 
    can be applied. 
    
    First we have to get rid of the Prophecy log messages, since they interfere
    with the log messages of the optimizer. We use the prompt: 
    
    'how to suppress prophecy log messages?' 
    
    The resulting code is shown below. 
    
    Notes:
    
    - Differential Evolution uses contiuous decision variables, so we have 
      to convert these into the strategy parameters prposed by o1-preview (see convert_x)
    - The boxed boundaries of the parameters are defined by the line:
        bounds = Bounds([0.001, 300, 3, 0], [1, 1600, 12, 1]) 
      You may ask o1-preview for feasible parameter ranges.
    - On an AMD 9950x 16 core processor on Linux we get about 7 trading simulations per second.
      The code works on Windows, but is significantly slower.  
    - btc_eval_params modifies the Dataframe used as its input parameter. How does this work, 
      since btc_eval_params is called in parallel? 
      fcmaes 'de' uses Python multiprocessing, so each Process has its own copy of the Dataframe.
    - the optimimal period is 535 days which is inconsistent with the assumed 4 year cycle.
    - After some hours we get the following optimized strategy parameters:
    
        changepoint prior scale: 0.05
        period: 535.0
        fourier order: 8
        seasonality_mode: additive
        Total Market Return: 15800.96%
        Total Strategy Return: 678644.32%
        Annualized Sharpe Ratio of the Strategy: 2.03
        
        May be there is some overfitting involved. So take this result with some grain of salt. 
        This tutorial shows how to automate parameter sweeping using parallel optimization. 
        You could use o1-preview or another LLM to create your own strategy which you then
        could optimize in a similar manner. 
'''

import pandas as pd
import numpy as np
import yfinance as yf
import sys
import matplotlib.pyplot as plt
from prophet import Prophet

# Suppress log messages from Prophet and its dependencies
import logging
logging.getLogger('prophet').setLevel(logging.ERROR)
logging.getLogger('cmdstanpy').setLevel(logging.ERROR)
logging.getLogger('pystan').setLevel(logging.ERROR)

# Remove any existing handlers
logger = logging.getLogger('cmdstanpy')
if logger.hasHandlers():
    logger.handlers.clear()

# Create a null handler to absorb logs
null_handler = logging.NullHandler()
logger.addHandler(null_handler)

# Suppress warnings
import warnings
warnings.filterwarnings('ignore')


# generated by o1-preview, refactored in a separate method 
def load_data(symbol = 'BTC-USD', start_date = '2013-01-01', end_date = '2024-10-30'):
    
    data = yf.download(symbol, start=start_date, end=end_date)
    
    # Prepare the data
    df = data.reset_index()[['Date', 'Adj Close']]
    df.rename(columns={'Date': 'ds', 'Adj Close': 'y'}, inplace=True)
    
    # Handle missing values
    df.dropna(inplace=True)
    return df

# generated by o1-preview    
def btc_strategy():
    
    df = load_data()
    
    # Initialize the Prophet model
    model = Prophet(
        daily_seasonality=False,
        weekly_seasonality=False,
        yearly_seasonality=True,  # Keep yearly seasonality
        changepoint_prior_scale=0.5  # Adjust for Bitcoin's volatility
    )
    
    # Add custom 4-year seasonality
    model.add_seasonality(
        name='four_year_cycle',
        period=1461,  # 365.25 days * 4 years (accounting for leap years)
        fourier_order=5
    )
    
    # Fit the model
    model.fit(df)
    
    # Create a DataFrame to hold predictions
    future = model.make_future_dataframe(periods=90)  # Forecasting the next 90 days
    forecast = model.predict(future)
    
    # Plot the forecast
    model.plot(forecast)
    plt.title('Bitcoin Price Forecast with 4-Year Cycle')
    plt.xlabel('Date')
    plt.ylabel('Price (USD)')
    plt.show()
    
    # Plot the components to see the effect of the 4-year cycle
    model.plot_components(forecast)
    plt.show()
    
    # Merge the forecast with the original data
    forecast = forecast[['ds', 'yhat']]
    df = df.merge(forecast, on='ds', how='left')
    
    # Calculate the daily change in predicted prices
    df['yhat_change'] = df['yhat'].diff()
    
    # Set a threshold for generating signals
    threshold = df['yhat_change'].std()  # Use standard deviation as threshold
    
    # Initialize the signal column
    df['signal'] = 0
    
    # Generate signals
    df.loc[df['yhat_change'] > threshold, 'signal'] = 1   # Buy signal
    df.loc[df['yhat_change'] < -threshold, 'signal'] = -1  # Sell signal
    
    # Calculate daily returns
    df['return'] = df['y'].pct_change()
    
    # Shift the signal by 1 day to simulate trading at the next day's open
    df['strategy_return'] = df['signal'].shift(1) * df['return']
    
    # Calculate cumulative returns
    df['cumulative_market_return'] = (1 + df['return']).cumprod()
    df['cumulative_strategy_return'] = (1 + df['strategy_return']).cumprod()
    plot_df(df)
    
# generated by o1-preview, refactored in a separate method     
def plot_df(df):
    # Plot cumulative returns
    plt.figure(figsize=(14, 7))
    plt.plot(df['ds'], df['cumulative_market_return'], label='Market Return')
    plt.plot(df['ds'], df['cumulative_strategy_return'], label='Strategy Return')
    plt.legend()
    plt.title('Cumulative Returns: Strategy vs. Market')
    plt.xlabel('Date')
    plt.ylabel('Cumulative Return')
    plt.show()
    
    # Calculate total returns
    total_market_return = df['cumulative_market_return'].iloc[-1] - 1
    total_strategy_return = df['cumulative_strategy_return'].iloc[-1] - 1
    
    print(f"Total Market Return: {total_market_return:.2%}")
    print(f"Total Strategy Return: {total_strategy_return:.2%}")
    
    # Plot the signals on the Bitcoin price
    plt.figure(figsize=(14, 7))
    plt.plot(df['ds'], df['y'], label='Bitcoin Price')
    
    # Plot buy signals
    buy_signals = df[df['signal'] == 1]
    plt.scatter(buy_signals['ds'], buy_signals['y'], marker='^', color='green', label='Buy Signal', alpha=1)
    
    # Plot sell signals
    sell_signals = df[df['signal'] == -1]
    plt.scatter(sell_signals['ds'], sell_signals['y'], marker='v', color='red', label='Sell Signal', alpha=1)
    
    plt.legend()
    plt.title('Trading Signals on Bitcoin Price')
    plt.xlabel('Date')
    plt.ylabel('Price (USD)')
    plt.show()
    
    # Calculate Sharpe Ratio
    strategy_returns = df['strategy_return'].dropna()
    sharpe_ratio = (strategy_returns.mean() / strategy_returns.std()) * np.sqrt(252) # Annualized Sharpe Ratio
    print(f"Annualized Sharpe Ratio of the Strategy: {sharpe_ratio:.2f}")
    
    
def btc_eval_params(df, changepoint_prior_scale, period, fourier_order, seasonality_mode):
        
    # Initialize the Prophet model
    model = Prophet(
        seasonality_mode=seasonality_mode,
        daily_seasonality=False,
        weekly_seasonality=False,
        yearly_seasonality=True,  # Keep yearly seasonality
        changepoint_prior_scale=changepoint_prior_scale  # Adjust for Bitcoin's volatility
    )
    
    # Add custom 4-year seasonality
    model.add_seasonality(
        name='four_year_cycle',
        period=period,  # 365.25 days * 4 years (accounting for leap years)
        fourier_order=fourier_order
    )
    
    # Fit the model
    model.fit(df)
    
    # Create a DataFrame to hold predictions
    future = model.make_future_dataframe(periods=90)  # Forecasting the next 90 days
    forecast = model.predict(future)

    # Merge the forecast with the original data
    forecast = forecast[['ds', 'yhat']]
    df = df.merge(forecast, on='ds', how='left')
    
    # Calculate the daily change in predicted prices
    df['yhat_change'] = df['yhat'].diff()
    
    # Set a threshold for generating signals
    threshold = df['yhat_change'].std()  # Use standard deviation as threshold
    
    # Initialize the signal column
    df['signal'] = 0
    
    # Generate signals
    df.loc[df['yhat_change'] > threshold, 'signal'] = 1   # Buy signal
    df.loc[df['yhat_change'] < -threshold, 'signal'] = -1  # Sell signal
    
    # Calculate daily returns
    df['return'] = df['y'].pct_change()
    
    # Shift the signal by 1 day to simulate trading at the next day's open
    df['strategy_return'] = df['signal'].shift(1) * df['return']
    
    # Calculate cumulative returns
    df['cumulative_market_return'] = (1 + df['return']).cumprod()
    df['cumulative_strategy_return'] = (1 + df['strategy_return']).cumprod()
    
    # Calculate total returns
    total_market_return = df['cumulative_market_return'].iloc[-1] - 1
    total_strategy_return = df['cumulative_strategy_return'].iloc[-1] - 1
    
    # print(f"Total Market Return: {total_market_return:.2%}")
    # print(f"Total Strategy Return: {total_strategy_return:.2%}")

    # # Calculate Sharpe Ratio
    strategy_returns = df['strategy_return'].dropna()
    sharpe_ratio = strategy_returns.mean() / strategy_returns.std() * np.sqrt(252)  # Annualized Sharpe Ratio    
    
    return sharpe_ratio, total_strategy_return, total_market_return, df
    
def btc_show_params(df, changepoint_prior_scale, period, fourier_order, seasonality_mode):
    sharpe_ratio, total_strategy_return, total_market_return, df = \
        btc_eval_params(df, changepoint_prior_scale, period, fourier_order, seasonality_mode)
    print(f"changepoint prior scale: {changepoint_prior_scale:.2f}")
    print(f"period: {period:.1f}")
    print(f"fourier order: {fourier_order}")
    print(f"seasonality_mode: {seasonality_mode}")
    plot_df(df)

# convert the continuous decision variable vector x into strategy parameters:
def convert_x(x):
    changepoint_prior_scale = x[0]
    period = int(x[1])
    fourier_order = int(x[2])
    seasonality_mode = 'multiplicative' if x[3] < 0.5 else 'additive'
    return changepoint_prior_scale, period, fourier_order, seasonality_mode
 
def btc_show_x(df, x):
    changepoint_prior_scale, period, fourier_order, seasonality_mode = convert_x(x)
    return btc_show_params(df, changepoint_prior_scale, period, fourier_order, seasonality_mode)
       
from loguru import logger
from functools import partial
from scipy.optimize import Bounds
from fcmaes import de
from fcmaes.optimizer import wrapper
    
def fitness(df, x):
    changepoint_prior_scale, period, fourier_order, seasonality_mode = convert_x(x)
    # use only negative sharpe ratio - we want to maximize 
    return -btc_eval_params(df, changepoint_prior_scale, period, fourier_order, seasonality_mode)[0]

def optimize_btc():    
    logger.remove()
    logger.add(sys.stdout, format="{time:HH:mm:ss.SS} | {level} | {message}", level="INFO")
    logger.add("log_{time}.txt", format="{time:HH:mm:ss.SS} | {level} | {message}", level="INFO")

    df = load_data()
    fit = wrapper(partial(fitness, df))
    bounds = Bounds([0.001, 300, 3, 0], [1, 1600, 12, 1]) 
    dim = len(bounds.lb)

    result = de.minimize(fit, dim, bounds, popsize = 32, max_evaluations=10000, workers=16)  
    btc_show_x(df, result.x)
    
def show_good_result():
    x = [0.05349976785054303, 535.7310259242943, 8.794794165972112, 0.5863217629860976]
    df = load_data()
    btc_show_x(df, x)

if __name__ == '__main__':
    # btc_strategy()
    optimize_btc()
    # show_good_result()
    pass