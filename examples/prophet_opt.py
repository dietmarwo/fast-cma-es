'''
    How to optimize an AI generated algorithmic trading strategy?
    
    Resolve dependencies:
    
    pip install plotly 
    pip install yfinance
    pip install fcmaes --upgrade
    pip install prophet
    
    This example code is partly generated by o1-preview.  
    LLMs can help to generate the code and to understand 
    its concepts. It can even propose ways to optimize the trading
    strategy. This example shows how this optimization process can be 
    automated using fcmaes. 
    
    - Executing the trading strategy takes time, so a complete parameter
    sweep is slow.
    - We exploit the fact the fcmaes uses parallel processes to speed up
    the optimization process. 
    - An evolutionary optimizer like Differential Evolution refines "promising"
    parameter sets, thereby avoiding to get stuck at local optima.
    
    Used prompts:

    'why are HMMs not typically used for point forecasts?'
    
        o1-preview lists the reasons, shows alternatives, one is to use Prophet.

    'show python code using Prophet for implementing a trading strategy'    
    'list this code in one chunk'
    
        the generated code desn't work with newest yfinance, so method 
        'load_data' requires a minor fix. 

    'how can the code be adapted to bitcoin reflecting the 4 year bitcoin cycle?'
    'apply this model to implement and test a trading strategy for BTC'
    
    Now we want to know how to optimize the strategy:

    'what can I try to optimize market return?'
    
        - Experiment with different values of changepoint_prior_scale.
        - Adjust the fourier_order for the yearly and custom 4-year seasonalities.
        - Change Seasonality Modes, can be either 'additive' or 'multiplicative'
        - ...

    Additionally - not mentioned by o1-preview, we could vary the 4-year cycle

    We show how fcmaes Differential Evolution can be applied to optimize these parameters. 
    
    But first we have to get rid of the Prophecy log messages, since they interfere
    with the log messages of the optimizer. We use the prompt: 
    
    'how to supress prophecy log messages?' 
    
    The resulting code is shown below. 
    
    Notes:
    
    - Differential Evolution uses contiuous decision variables, so we have 
      to convert these into the strategy parameters prposed by o1-preview (see convert_x)
    - The boxed boundaries of the parameters are defined by the line:
        bounds = Bounds([0.001, 300, 3, 0], [1, 1600, 12, 1]) 
      You may ask o1-preview for feasible parameter ranges.
    - On an AMD 9950x 16 core processor on Linux we get about 7 trading simulations per second.
      The code works on Windows, but is significantly slower.  
    - btc_eval_params modifies the Dataframe used as its input parameter. How does this work, 
      since btc_eval_params is called in parallel? 
      fcmaes 'de' uses Python multiprocessing, so each Process has its own copy of the Dataframe.
    - the optimimal period is 535 days which is inconsistent with the assumed 4 year cycle.
    - After some hours we get the following optimized strategy parameters:
    
        changepoint prior scale: 0.05
        period: 535.0
        fourier order: 8
        seasonality_mode: additive
        Total Market Return: 15800.96%
        Total Strategy Return: 678644.32%
        Annualized Sharpe Ratio of the Strategy: 2.03
        
        May be there is some overfitting involved. So take this result with some grain of salt. 
        This tutorial shows how to automate parameter sweeping using parallel optimization. 
        You could use o1-preview or another LLM to create your own strategy which you then
        could optimize in a similar manner. 
        
    What if we ask o1-preview how to implement optimization of the strategy parameters?
    
    It recommends to use https://optuna.org/[Optuna] which indeed is a very good choice. 
    We tried other alternatives, but only Optuna successfully parallelized the tranding strategy
    simulation. Its default optimizer (using Parzen Trees) does a good job, comparable to what 
    fcmaes DE can achieve:
    
    - Good results for low evaluation counts.
    - Strange slow-down for high evaluation counts for this example.
    
    Other Optuna optimizers (like Bayesian Optimization and CMA-ES) don't work as well. 
    
    Optuna has a valuable feature: A https://github.com/optuna/optuna-dashboard[dashboard]
    providing real time insights into the optimization process. 
    
    Fortunately we can make this dashboard work also for fcmaes:
    
    - There is an Optuna journal file generating wrapper for the objective function used by fcmaes
    optimizers. Because of the order parallel objective function evaluations are scheduled by fcmaes,
    some results cannot be captured, but in practice the dashboard works quite well.
    Instead of "batches" a more sophisticated parallelization approach is implemented, which exploits the fact
    that objective function evaluations can require vastly different execution times. 
    So evaluation in "batches" would cause some CPU cores to idle waiting for the slow ones. 
    
    Using fcmaes ask/tell interface batch evaluation can be enforced if you prefer this.
'''

import pandas as pd
import numpy as np
import yfinance as yf
import sys
import matplotlib.pyplot as plt
from prophet import Prophet

# Suppress log messages from Prophet and its dependencies
import logging
logging.getLogger('prophet').setLevel(logging.ERROR)
logging.getLogger('cmdstanpy').setLevel(logging.ERROR)
logging.getLogger('pystan').setLevel(logging.ERROR)

# Remove any existing handlers
logger = logging.getLogger('cmdstanpy')
if logger.hasHandlers():
    logger.handlers.clear()

# Create a null handler to absorb logs
null_handler = logging.NullHandler()
logger.addHandler(null_handler)

# Suppress warnings
import warnings
warnings.filterwarnings('ignore')


# generated by o1-preview, refactored in a separate method 
def load_data(symbol = 'BTC-USD', start_date = '2013-01-01', end_date = '2024-10-30'):
    
    data = yf.download(symbol, start=start_date, end=end_date)
    data.columns = data.columns.get_level_values(0) # take first element of the multi index column label
    # Prepare the data
    df = data.reset_index()[['Date', 'Adj Close']]
    df.rename(columns={'Date': 'ds', 'Adj Close': 'y'}, inplace=True)
    df['ds'] = df['ds'].dt.tz_localize(None) # remove time-zone info
    
    # Handle missing values
    df.dropna(inplace=True)
    return df

# generated by o1-preview    
def btc_strategy():
    
    df = load_data()
    
    # Initialize the Prophet model
    model = Prophet(
        daily_seasonality=False,
        weekly_seasonality=False,
        yearly_seasonality=True,  # Keep yearly seasonality
        changepoint_prior_scale=0.5  # Adjust for Bitcoin's volatility
    )
    
    # Add custom 4-year seasonality
    model.add_seasonality(
        name='four_year_cycle',
        period=1461,  # 365.25 days * 4 years (accounting for leap years)
        fourier_order=5
    )
    
    # Fit the model
    model.fit(df)
    
    # Create a DataFrame to hold predictions
    future = model.make_future_dataframe(periods=90)  # Forecasting the next 90 days
    forecast = model.predict(future)
    
    # Plot the forecast
    model.plot(forecast)
    plt.title('Bitcoin Price Forecast with 4-Year Cycle')
    plt.xlabel('Date')
    plt.ylabel('Price (USD)')
    plt.show()
    
    # Plot the components to see the effect of the 4-year cycle
    model.plot_components(forecast)
    plt.show()
    
    # Merge the forecast with the original data
    forecast = forecast[['ds', 'yhat']]
    df = df.merge(forecast, on='ds', how='left')
    
    # Calculate the daily change in predicted prices
    df['yhat_change'] = df['yhat'].diff()
    
    # Set a threshold for generating signals
    threshold = df['yhat_change'].std()  # Use standard deviation as threshold
    
    # Initialize the signal column
    df['signal'] = 0
    
    # Generate signals
    df.loc[df['yhat_change'] > threshold, 'signal'] = 1   # Buy signal
    df.loc[df['yhat_change'] < -threshold, 'signal'] = -1  # Sell signal
    
    # Calculate daily returns
    df['return'] = df['y'].pct_change()
    
    # Shift the signal by 1 day to simulate trading at the next day's open
    df['strategy_return'] = df['signal'].shift(1) * df['return']
    
    # Calculate cumulative returns
    df['cumulative_market_return'] = (1 + df['return']).cumprod()
    df['cumulative_strategy_return'] = (1 + df['strategy_return']).cumprod()
    plot_df(df)
    
# generated by o1-preview, refactored in a separate method     
def plot_df(df):
    # Plot cumulative returns
    plt.figure(figsize=(14, 7))
    plt.plot(df['ds'], df['cumulative_market_return'], label='Market Return')
    plt.plot(df['ds'], df['cumulative_strategy_return'], label='Strategy Return')
    plt.legend()
    plt.title('Cumulative Returns: Strategy vs. Market')
    plt.xlabel('Date')
    plt.ylabel('Cumulative Return')
    plt.show()
    
    # Calculate total returns
    total_market_return = df['cumulative_market_return'].iloc[-1] - 1
    total_strategy_return = df['cumulative_strategy_return'].iloc[-1] - 1
    
    print(f"Total Market Return: {total_market_return:.2%}")
    print(f"Total Strategy Return: {total_strategy_return:.2%}")
    
    # Plot the signals on the Bitcoin price
    plt.figure(figsize=(14, 7))
    plt.plot(df['ds'], df['y'], label='Bitcoin Price')
    
    # Plot buy signals
    buy_signals = df[df['signal'] == 1]
    plt.scatter(buy_signals['ds'], buy_signals['y'], marker='^', color='green', label='Buy Signal', alpha=1)
    
    # Plot sell signals
    sell_signals = df[df['signal'] == -1]
    plt.scatter(sell_signals['ds'], sell_signals['y'], marker='v', color='red', label='Sell Signal', alpha=1)
    
    plt.legend()
    plt.title('Trading Signals on Bitcoin Price')
    plt.xlabel('Date')
    plt.ylabel('Price (USD)')
    plt.show()
    
    # Calculate Sharpe Ratio
    strategy_returns = df['strategy_return'].dropna()
    sharpe_ratio = (strategy_returns.mean() / strategy_returns.std()) * np.sqrt(252) # Annualized Sharpe Ratio
    print(f"Annualized Sharpe Ratio of the Strategy: {sharpe_ratio:.2f}")
    
    
def btc_eval_params(df, changepoint_prior_scale, period, fourier_order, seasonality_mode):
        
    # Initialize the Prophet model
    model = Prophet(
        seasonality_mode=seasonality_mode,
        daily_seasonality=False,
        weekly_seasonality=False,
        yearly_seasonality=True,  # Keep yearly seasonality
        changepoint_prior_scale=changepoint_prior_scale  # Adjust for Bitcoin's volatility
    )
    
    # Add custom 4-year seasonality
    model.add_seasonality(
        name='four_year_cycle',
        period=period,  # 365.25 days * 4 years (accounting for leap years)
        fourier_order=fourier_order
    )
    
    # Fit the model
    model.fit(df)
    
    # Create a DataFrame to hold predictions
    future = model.make_future_dataframe(periods=90)  # Forecasting the next 90 days
    forecast = model.predict(future)

    # Merge the forecast with the original data
    forecast = forecast[['ds', 'yhat']]
    df = df.merge(forecast, on='ds', how='left')
    
    # Calculate the daily change in predicted prices
    df['yhat_change'] = df['yhat'].diff()
    
    # Set a threshold for generating signals
    threshold = df['yhat_change'].std()  # Use standard deviation as threshold
    
    # Initialize the signal column
    df['signal'] = 0
    
    # Generate signals
    df.loc[df['yhat_change'] > threshold, 'signal'] = 1   # Buy signal
    df.loc[df['yhat_change'] < -threshold, 'signal'] = -1  # Sell signal
    
    # Calculate daily returns
    df['return'] = df['y'].pct_change()
    
    # Shift the signal by 1 day to simulate trading at the next day's open
    df['strategy_return'] = df['signal'].shift(1) * df['return']
    
    # Calculate cumulative returns
    df['cumulative_market_return'] = (1 + df['return']).cumprod()
    df['cumulative_strategy_return'] = (1 + df['strategy_return']).cumprod()
    
    # Calculate total returns
    total_market_return = df['cumulative_market_return'].iloc[-1] - 1
    total_strategy_return = df['cumulative_strategy_return'].iloc[-1] - 1
    
    # print(f"Total Market Return: {total_market_return:.2%}")
    # print(f"Total Strategy Return: {total_strategy_return:.2%}")

    # # Calculate Sharpe Ratio
    strategy_returns = df['strategy_return'].dropna()
    sharpe_ratio = strategy_returns.mean() / strategy_returns.std() * np.sqrt(252)  # Annualized Sharpe Ratio    
    
    return sharpe_ratio, total_strategy_return, total_market_return, df
    
def btc_show_params(df, changepoint_prior_scale, period, fourier_order, seasonality_mode):
    sharpe_ratio, total_strategy_return, total_market_return, df = \
        btc_eval_params(df, changepoint_prior_scale, period, fourier_order, seasonality_mode)
    print(f"changepoint prior scale: {changepoint_prior_scale:.2f}")
    print(f"period: {period:.1f}")
    print(f"fourier order: {fourier_order}")
    print(f"seasonality_mode: {seasonality_mode}")
    plot_df(df)

# convert the continuous decision variable vector x into strategy parameters:
def convert_x(x):
    changepoint_prior_scale = x[0]
    period = int(x[1])
    fourier_order = int(x[2])
    seasonality_mode = 'multiplicative' if int(x[3]) < 0.5 else 'additive'
    return changepoint_prior_scale, period, fourier_order, seasonality_mode
 
def btc_show_x(df, x):
    changepoint_prior_scale, period, fourier_order, seasonality_mode = convert_x(x)
    return btc_show_params(df, changepoint_prior_scale, period, fourier_order, seasonality_mode)
       
from loguru import logger
from functools import partial
from scipy.optimize import Bounds
from fcmaes import de, decpp, evaluator
from fcmaes.optimizer import wrapper
from fcmaes.journal import Journal, journal_wrapper
    
def fitness(df, x):
    changepoint_prior_scale, period, fourier_order, seasonality_mode = convert_x(x)
    # use only negative sharpe ratio - we want to maximize 
    return -btc_eval_params(df, changepoint_prior_scale, period, fourier_order, seasonality_mode)[0]

def optimize_btc():    
    logger.remove()
    logger.add(sys.stdout, format="{time:HH:mm:ss.SS} | {level} | {message}", level="INFO")
    logger.add("log_{time}.txt", format="{time:HH:mm:ss.SS} | {level} | {message}", level="INFO")

    df = load_data()
    fit = wrapper(partial(fitness, df))
    bounds = Bounds([0.001, 300, 3, 0], [1, 1600, 11.999, 1.0]) 
    dim = len(bounds.lb)
    batch_size = 16
    study_id = 0
    
    # using journal wrapper
    fit = journal_wrapper(fit, bounds, "journal.log", "BTC_strategy", study_id, batch_size)
    result = de.minimize(fit, dim, bounds, popsize = batch_size, 
                         max_evaluations=10000, workers=batch_size)  
    btc_show_x(df, result.x)

def optimize_btc_ask_tell():    
    logger.remove()
    logger.add(sys.stdout, format="{time:HH:mm:ss.SS} | {level} | {message}", level="INFO")
    logger.add("log_{time}.txt", format="{time:HH:mm:ss.SS} | {level} | {message}", level="INFO")

    df = load_data()
    fit = wrapper(partial(fitness, df))
    bounds = Bounds([0.001, 300, 3, 0], [1, 1600, 11.999, 1.0]) 
    dim = len(bounds.lb)
    batch_size = 16
    study_id = 0

    # using ask / tell interface + journal
    journal = Journal("journal2.log", "BTC_strategy", 1)
    pfit = evaluator.parallel(fit, workers=batch_size)   
    es = de.DE(dim, bounds = bounds, popsize=batch_size)
     
    iters = 10000
    trial_id = 1
    
    for iter in range(iters):
        journal.write_starts(study_id, batch_size)
        xs = es.ask()
        journal.write_xs(trial_id, xs, bounds)
        ys = pfit(xs)    
        journal.write_ys(trial_id, ys)
        trial_id += batch_size
        stop = es.tell(ys)
        if stop != 0:
            break 
    x = es.best_x
    y = es.best_value
    btc_show_x(df, x)   
    
def show_good_result():
    # Total Market Return: 15800.96%
    # Total Strategy Return: 708605.56%
    # Annualized Sharpe Ratio of the Strategy: 2.02
    x = [0.05398682129917759, 534.0752343371352, 8.880921187256302, 1.0]
    df = load_data()
    y = fitness(df, x)
    btc_show_x(df, x)

if __name__ == '__main__':
    #btc_strategy()
    #optimize_btc()
    #optimize_btc_ask_tell()
    show_good_result()
    pass